//! Various pieces of common functionality.
use super::*;

const LOG_TARGET: &str = "Fund Admin pallet migration: ";
use frame_support::{pallet_prelude::*, log, traits::OnRuntimeUpgrade, storage_alias, Twox64Concat, Identity};
use sp_runtime::Saturating;

use crate::types::*;

mod v0 {
	use super::*;

	#[derive(Decode, Encode)]
	pub struct OldDrawdownData<T: Config> {
        pub project_id: ProjectId,
        pub drawdown_number: DrawdownNumber,
        pub drawdown_type: DrawdownType,
        pub total_amount: TotalAmount,
        pub status: DrawdownStatus,
        pub bulkupload_documents: Option<Documents<T>>,
        pub bank_documents: Option<Documents<T>>,
        pub description: Option<FieldDescription>,
        pub feedback: Option<FieldDescription>,
        pub status_changes: DrawdownStatusChanges<T>,
        pub created_date: CreatedDate,
        pub closed_date: CloseDate,
    }

	// #[cfg(feature = "try-runtime")]
	#[storage_alias]
	//pub(super) type DrawdownsInfoOf<T: Config> = StorageMap<Pallet<T>, Twox64Concat, DrawdownId, DrawdownData<T>>;
	pub(super) type DrawdownsInfoOf<T: Config> = StorageMap<Pallet<T>, Identity, DrawdownId, DrawdownData<T>>;

}

pub mod v1 {
    use super::*;
	pub use super::v0::OldDrawdownData;

	impl<T: Config> OldDrawdownData<T> {
		fn migrate_to_v1(self) -> DrawdownData<T> {
			DrawdownData {
				project_id: self.project_id,
				drawdown_number: self.drawdown_number,
				drawdown_type: self.drawdown_type,
				total_amount: self.total_amount,
				status: self.status,
				bulkupload_documents: self.bulkupload_documents,
				bank_documents: self.bank_documents,
				description: self.description,
				feedback: self.feedback,
				status_changes: self.status_changes,
				recovery_record:  DrawdownRecoveryRecord::<T>::default(),
				created_date: self.created_date,
				closed_date: self.closed_date,
			}
		}
	}


	pub struct MigrateToV1<T>(sp_std::marker::PhantomData<T>);
	impl <T: Config> OnRuntimeUpgrade for MigrateToV1<T> {
		#[allow(deprecated)]
		fn on_runtime_upgrade() -> Weight {
			let onchain_version =  Pallet::<T>::on_chain_storage_version();
			let current_version = Pallet::<T>::current_storage_version();
	
			log::info!(
				target: LOG_TARGET,
				"Running migration with current storage version: {:?} / onchain version: {:?}",
				current_version,
				onchain_version
			);
			
			if onchain_version == 0 && current_version == 1 {
				// migrate to v1
				// Very inefficient, mostly here for illustration purposes.
				let count = v0::DrawdownsInfoOf::<T>::iter().count();
				let mut translated = 0u64;
	
				DrawdownsInfo::<T>::translate::<
				OldDrawdownData<T>, _>(
					|_key: DrawdownId, value: OldDrawdownData<T>| {
						translated.saturating_inc();
						Some(value.migrate_to_v1())
					}
				);

				// Update storage version
				current_version.put::<Pallet<T>>();

				log::info!(
					target: LOG_TARGET,
					"Upgraded {} names from {} initial names, storage to version {:?}",
					count,
					translated,
					current_version
				);


				T::DbWeight::get().reads_writes(translated + 1, translated + 1)
			} else {
				log::info!(
					target: LOG_TARGET,
					"Migration did not execute. This probably should be removed"
				);
				T::DbWeight::get().reads(1)
			}
		}

		// #[cfg(feature = "try-runtime")]
		// fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
		// 	log::info!(
		// 		target: LOG_TARGET,
		// 		"pre_upgrade: current storage version {:?}",
		// 		Pallet::<T>::current_storage_version()
		// 	);
		// 	let current_version = Pallet::<T>::current_storage_version();
		// 	let onchain_version = Pallet::<T>::on_chain_storage_version();
		// 	ensure!(
		// 		onchain_version == 1,
		// 		"must upgrade linearly"
		// 	);
		// 	ensure!(
		// 		current_version == 2,
		// 		"migration from version 1 to 2."
		// 	);
		// 	let prev_count = v1::NameOf::<T>::iter().count();
		// 	let names = v1::NameOf::<T>::iter_keys().count() as u32;			
		// 	let decodable_names = v1::NameOf::<T>::iter_values().count() as u32;
		// 	log::info!(
		// 		target: LOG_TARGET,
		// 		"pre_upgrade: {:?} names, {:?} decodable names, {:?} total",
		// 		names,
		// 		decodable_names,
		// 		prev_count,
		// 	);
		// 	ensure!(
		// 		names == decodable_names,
		// 		"Not all values are decodable."
		// 	);

		// 	Ok((prev_count as u32).encode())
		// }

		// #[cfg(feature = "try-runtime")]
		// fn post_upgrade(prev_count: Vec<u8>) -> Result<(), &'static str> {
		// 	let prev_count: u32 = Decode::decode(&mut prev_count.as_slice()).expect(
		// 		"the state parameter should be something that was generated by pre_upgrade",
		// 	);
		// 	let post_count = crate::NameOf::<T>::iter().count() as u32;
		// 	assert_eq!(
		// 		prev_count, post_count,
		// 		"the records count before and after the migration should be the same"
		// 	);

		// 	let current_version = Pallet::<T>::current_storage_version();
		// 	let onchain_version = Pallet::<T>::on_chain_storage_version();

		// 	ensure!(current_version == 2, "must_upgrade to v2");
		// 	assert_eq!(
		// 		current_version, onchain_version,
		// 		"after migration, the current_version and onchain_version should be the same"
		// 	);
		// 	crate::NameOf::<T>::iter().for_each(|(_key, (name, _deposit))| {
		// 		assert!(name.third == AccountStatus::Active,
		// 		"accounts should only be Active. None should be in Inactive status, or undefined state")
		// 	});
		// 	Ok(())
		// }

	}

}